# Chapter4 内存隔离安全性：地址空间（优先级1）
## 完成情况
- 因为之前的实验中对内存模块代码理解比较差，所以浪费了很多时间，而且有些大部分模块的代码如果可用就直接复制了
- user模块elf文件的使用了吴一凡同学的加载方法，测试的例子和上一章相同
- 本章顺利实现了物理内存的动态分配，页表的加载，以及elf文件的解析
- 目前还未实现用户程序堆空间的动态分配的系统调用，因为理解还不够透彻
```
OpenSBI v0.6
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 120 KB
Runtime SBI Version    : 0.2

MIDELEG : 0x0000000000000222
MEDELEG : 0x000000000000b109
PMP0    : 0x0000000080000000-0x000000008001ffff (A)
PMP1    : 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
[K] mod memory initialized
[K] mod interrupt init
power_7 [10000/240000]
power_7 [20000/240000]
power_7 [30000/240000]
power_7 [40000/240000]
power_7 [50000/240000]
power_7 [60000/240000]
power_7 [70000/240000]
power_7 [80000/240000]
power_7 [90000/240000]
power_7 [100000/240000]
power_7 [110000/240000]
power_7 [120000/240000]
power_3 [10000/300000]
power_3 [20000/300000]
power_3 [30000/300000]
power_3 [40000/300000]
power_3 [50000/300000]
power_3 [60000/300000]
power_3 [70000/300000]
power_3 [80000/300000]
power_3 [90000/300000]
power_3 [100000/300000]
power_3 [110000/300000]
power_3 [120000/300000power_5 [10000/210000]
power_5 [20000/210000]
power_5 [30000/210000]
power_5 [40000/210000]
power_5 [50000/210000]
power_5 [60000/210000]
power_5 [70000/210000]
power_5 [80000/210000]
power_5 [90000/210000]
power_5 [100000/210000]
power_5 [110000/210000]
power_5 [120000/210000]
power_5 [power_7 [130000/240000]
power_7 [140000/240000]
power_7 [150000/240000]
power_7 [160000/240000]
power_7 [170000/240000]
power_7 [180000/240000]
power_7 [190000/240000]
power_7 [200000/240000]
power_7 [210000/240000]
power_7 [220000/240000]
power_7 []
power_3 [130000/300000]
power_3 [140000/300000]
power_3 [150000/300000]
power_3 [160000/300000]
power_3 [170000/300000]
power_3 [180000/300000]
power_3 [190000/300000]
power_3 [200000/300000]
power_3 [210000/300000]
power_3 [220000/300000]
power_3 [230000/300000]
power_3 [240000/300000]
power_3 [250000/300000]
130000/210000]
power_5 [140000/210000]
power_5 [150000/210000]
power_5 [160000/210000]
power_5 [170000/210000]
power_5 [180000/210000]
power_5 [190000/210000]
power_5 [200000/210000]
power_5 [210000/210000]
5^210000 = 527227302(mod 998244353)
Test power_5 OK!
[K] exit (:
3
230000/240000]
power_7 [power_3 [260000/300000]
power_3 [270000/300000]
power_3 [280000/300000]
power_3 [290000/300000]
power_3 [300000/300000]
3^300000 = 612461288(mod 998244353)
Test power_3 OK!
[K] exit (:
2
240000/240000]
7^240000 = 304164893(mod 998244353)
Test power_7 OK!
[K] exit (:
1
Test sleep OK!
[K] exit (:
0
panic: '[S] all app end '
```
## 主要动机
提高应用间的安全性（通过页机制实现隔离）

附带好处：应用程序地址空间可以相同，便于应用程序的开发

## 用户程序
应用程序与上一章基本相同，只不过应用程序的地址空间起始位置应该相同。而且这一章需要将 ELF 链接进内核而不是二进制镜像。

特别的，可以设置访问其他应用程序地址空间或是访问内核地址空间的应用程序，内核会将其杀死。

在用户库使用 sbrk 申请动态分配空间而不是放在数据段中。

## 内核应完成功能
- 内核动态内存分配器（对于 Rust 而言，对于 C 仍可以考虑静态分配）
- 物理页帧分配器
- 页表机制，特别是用户和内核地址空间的隔离（参考 xv6）
- ELF 解析和加载（在内核初始化的时候完成全部的地址空间创建和加载即可）
## 新增系统调用
- sys_sbrk：拓展或缩减当前应用程序的堆空间大小