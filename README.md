# Chapter2 批处理系统（优先级1）
## 完成情况
- 支持内核栈和用户栈之间的切换，程序执行系统调用会陷入S态进行，并切换到内核栈，保存寄存器的值，执行完毕后恢复寄存器，并切换回用户栈。
- 目前支持的用户程序为hello_world和count_sum，运行时数据放在用户栈，无法接触到内核。加载顺序是固定的，执行完最后一个程序系统结束。
- 目前主要的缺陷是用户程序和内核都放在一起，且编译完成的用户程序地址还在内核中，没有做到真正的分离。且应用数量是写死的，如果增加的话需要更改内核代码。因为第二章只要求实现2个用户程序，所以现在的代码基本满足要求。
- 打算真正的分离放到后面的章节来做，比如调度或者实现真实的进程的时候。

## 主要动机
内核不会被应用程序破坏

## 用户程序
支持应用进行计算与结果输出。在裸机上输出 Hello world，就像在其他 OS 上一样。但应用程序无法破坏内核，但能得到内核的服务。

app列表：

- hello_world：输出字符串。
- count_sum：累加一维数组的和，并输出结果。


## 内核应完成功能
设置好内核和用户运行的栈，内核初始化完成后通过 sret 跳转到用户程序进行执行，然后在用户程序系统调用的时候完成特权级切换、上下文保存/恢复及栈的切换

按顺序加载运行多个应用程序。当应用程序出错（非法指令基于 RustSBI 不容易完成，比如访问非法的物理地址）之后直接杀死应用程序并切换到下一个。

## 新增系统调用
- sys_write：向串口写
- sys_exit： 表明任务结束。
## 实现备注
将编译之后的用户镜像和内核打包到一起放到内存上

分离用户和内核特权级，保护OS，用户需要请求内核提供的服务